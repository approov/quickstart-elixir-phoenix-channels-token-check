# Approov Token Quickstart

This quickstart is for developers familiar with Phoenix who are looking for a quick intro into how they can add [Approov](https://approov.io) into an existing project. Therefore this will guide you through the necessary steps for adding Approov to an existing Elixir Phoenix Channels server.

## TOC - Table of Contents

* [Why?](#why)
* [How it Works?](#how-it-works)
* [Requirements](#requirements)
* [Approov Setup](#approov-setup)
* [Approov Token Check](#approov-token-check)
* [Test the Approov Integration](#test-your-approov-integration)


## Why?

To lock down your Elixir Phoenix Channels server to your mobile app. Please read the brief summary in the [Approov Overview](/OVERVIEW.md#why) at the root of this repo or visit our [website](https://approov.io/product) for more details.

[TOC](#toc---table-of-contents)


## How it works?

For more background on Approov, see the [Approov Overview](/OVERVIEW.md#how-it-works) at the root of this repo.

### Approov Token Check

Take a look at the [Approov Token Plug](/src/approov-protected-server/token-check/echo/lib/echo_web/plugs/approov_token_plug.ex) module to see how the Approov token check is invoked in the `call/2` function. To see the simple code for the Approov token check, you need to look into the `verify/1` function in the [Approov Token](/src/approov-protected-server/token-check/echo/lib/approov_token.ex) module.


[TOC](#toc---table-of-contents)


## Requirements

To complete this quickstart you will need both the Phoenix and the Approov CLI tool installed.

* Phoenix - Follow the official installation instructions from [here](https://hexdocs.pm/phoenix/installation.html#content)
* Approov CLI - Follow our [installation instructions](https://approov.io/docs/latest/approov-installation/#approov-tool) and read more about each command and its options in the [documentation reference](https://approov.io/docs/latest/approov-cli-tool-reference/)

[TOC](#toc---table-of-contents)


## Approov Setup

To use Approov with the Elixir Phoenix Channels server you need a small amount of configuration. First, Approov needs to know the API domain that will be protected. Second, the Elixir Phoenix Channels server needs the Approov Base64 encoded secret that will be used to verify the tokens generated by the Approov cloud service.

### Configure API Domain

Approov needs to know the domain name of the API for which it will issue tokens.

Add it with:

```text
approov api -add your.api.domain.com
```

> **NOTE:** By default a symmetric key (HS256) is used to sign the Approov token on a valid attestation of the mobile app for each API domain it's added with the Approov CLI, so that all APIs will share the same secret and the backend needs to take care to keep this secret secure.
>
> A more secure alternative is to use asymmetric keys (RS256 or others) that allows for a different keyset to be used on each API domain and for the Approov token to be verified with a public key that can only verify, but not sign, Approov tokens.
>
> To implement the asymmetric key you need to change from using the symmetric HS256 algorithm to an asymmetric algorithm, for example RS256, that requires you to first [add a new key](https://approov.io/docs/latest/approov-usage-documentation/#adding-a-new-key), and then specify it when [adding each API domain](https://approov.io/docs/latest/approov-usage-documentation/#keyset-key-api-addition). Please visit [Managing Key Sets](https://approov.io/docs/latest/approov-usage-documentation/#managing-key-sets) on the Approov documentation for more details.

Adding the API domain also configures the [dynamic certificate pinning](https://approov.io/docs/latest/approov-usage-documentation/#approov-dynamic-pinning) setup, out of the box.

> **NOTE:** By default the pin is extracted from the public key of the leaf certificate served by the domain, as visible to the box executing the Approov CLI command and the Approov servers.

### Approov Secret

Approov tokens are signed with a symmetric secret. To verify tokens, you need to grab the secret using the [Approov secret command](https://approov.io/docs/latest/approov-cli-tool-reference/#secret-command) and plug it into the Elixir Phoenix Channels server environment to check the signatures of the [Approov Tokens](https://www.approov.io/docs/latest/approov-usage-documentation/#approov-tokens) that it processes.

First, enable your Approov `admin` role with:

```bash
eval `approov role admin`
````

For the Windows powershell:

```bash
set APPROOV_ROLE=admin:___YOUR_APPROOV_ACCOUNT_NAME_HERE___
````

Next, retrieve the Approov secret with:

```text
approov secret -get base64url
```

#### Set the Approov Secret

Export the Approov secret into the environment:

```text
export APPROOV_BASE64URL_SECRET=approov_base64url_secret_here
```

For the Approov secret to be available during runtime you need to add some code to the Elixir configuration, but Elixir has compile time and runtime configuration. To not duplicate the Approov secret configuration we recommend you to add it only in the runtime configuration.

##### From Elixir 1.11

If doesn't exist already, create the file `config/runtime.exs` and then add:

```elixir
import Config

approov_secret =
  System.get_env("APPROOV_BASE64URL_SECRET") ||
    raise "Environment variable APPROOV_BASE64URL_SECRET is missing."

config :YOUR_APP, ApproovToken,
  secret_key: approov_secret
```

The runtime configuration will run every-time a release or a Mix project is started.

##### From Elixir 1.9 to 1.10

The runtime configuration in this versions is `config/releases.exs`, but with the difference that it only runs when a release is booted, not when a Mix project is started, where only the compile time configuration is used.

To avoid duplicating the code for reading the Approov secret in both configurations you may want to import the runtime configuration from within your compile time configuration.

Add to `config/releases.exs`:

```elixir
import Config

approov_secret =
  System.get_env("APPROOV_BASE64URL_SECRET") ||
    raise "Environment variable APPROOV_BASE64URL_SECRET is missing."

config :YOUR_APP, ApproovToken,
  secret_key: approov_secret

config :YOUR_APP, YOUR_APP.Endpoint, server: true
```

Then import this file from `config/config.exs`:

```elixir
import_config "releases.exs"

# Import environment specific config. This must remain at the bottom
# of this file so it overrides the configuration defined above.
import_config "#{Mix.env()}.exs"
```

With this approach you are in fact emulating the Elixir `1.11` behaviour for the runtime configuration `config/runtime.exs`.

##### Until Elixir 1.8

Until Elixir `1.8` version no official way existed of reading values for each time the server was started from a release or a Mix project, and lots of different workarounds existed, and you can see some of them being discussed in the Elixir Forum, like in this [topic](https://elixirforum.com/t/phoenix-distillery-kubernetes-and-runtime-env-variables/13399).

[TOC](#toc---table-of-contents)


## Approov Token Check

For protecting HTTP requests and/or Websocket requests you need to add the Approov token module to perform the token check, that will use the [joken-elixir/joken](httpshttps://github.com/joken-elixir/joken) package to verify the token signature, and a custom function to check the expiration time for it.

Add the [Approov Token](/src/approov-protected-server/token-check/echo/lib/approov_token.ex) module into your project at `lib/approov_token.ex`:

```elixir
defmodule ApproovToken do

  use Joken.Config

  @impl Joken.Config
  def token_config, do: default_claims(skip: [:aud, :iat, :iss, :jti, :nbf])

  # Verifies the token from an HTTP request or from a Websockets connection/event
  def verify_token(params) do
    with {:ok, approov_token} <- _get_approov_token(params),
         {:ok, approov_token_claims} <- _decode_and_verify(approov_token) do

      {:ok, approov_token_claims}
    else
      {:error, reason} ->
        # You may want to add logging here
        {:error, reason}
    end
  end


  ########################
  # APPROOV TOKEN FETCH
  ########################

  # For when the Approov token is the header of a regular HTTP Request
  defp _get_approov_token(%Plug.Conn{} = conn) do
    case Plug.Conn.get_req_header(conn, "x-approov-token") do
      [] ->
        _get_approov_token(conn.params)

      [approov_token | _] ->
        {:ok, approov_token}
    end
  end

  # Fetch for a Phoenix Channel event, where the token is provided in the event payload.
  defp _get_approov_token(%{"x-approov-token" => approov_token}), do: {:ok, approov_token}
  defp _get_approov_token(%{"X-Approov-Token" => approov_token}), do: {:ok, approov_token}

  # Catch failure to fetch the Approov token from the WebSocket upgrade request
  # or from the Phoenix Channel event.
  defp _get_approov_token(_params) do
    {:error, :missing_approov_token}
  end


  ########################
  # APPROOV TOKEN CHECK
  ########################

  defp _decode_and_verify(approov_token) do
    secret = Application.fetch_env!(:echo, ApproovToken)[:secret_key]

    # call `verify_and_validate/2` injected by `use Joken.Config`
    case verify_and_validate(approov_token, Joken.Signer.create("HS256", secret)) do
      {:ok, %{"exp" => _expiration}} = result ->
        result

      # The library only checks the `exp` when present, and verifies successfully
      # without it, and doesn't have an option to enforce it.
      {:ok, _claims} ->
        {:error, :missing_expiration_time}

      result ->
        result
    end
  end
end
```

### Approov Token Check for HTTP Requests

First, add the [Approov Token Plug](/src/approov-protected-server/token-check/echo/lib/echo_web/plugs/approov_token_plug.ex) module to your project at `lib/your_app_web/plugs/approov_token_plug.ex`:

```elixir
defmodule YourAppWeb.ApproovTokenPlug do

  def init(opts), do: opts

  def call(conn, _opts) do
    case ApproovToken.verify_token(conn) do
      {:ok, approov_token_claims} ->
        conn
        |> Plug.Conn.put_private(:echo_approov_token_claims, approov_token_claims)

      {:error, _reason} ->
        conn
        |> _halt_connection()
    end
  end

  defp _halt_connection(conn) do
    conn
    |> Plug.Conn.put_status(401)
    |> Phoenix.Controller.json(%{})
    |> Plug.Conn.halt()
  end

end
```

> **NOTE:** When the Approov token validation fails we return a `401` with an empty body, because we don't want to give clues to an attacker about the reason the request failed, and you can go even further by returning a `400`.

Now, create and use the pipeline for the Approov token check at `lib/your_app_web/router.ex`:

```elixir
# @IMPORTANT:
#
# Ideally any other type of Authentication pipeline should only come after the
# Approov token. For example, doesn't make sense to check the user credentials
# before you check if you can trust in the request with the Approov Token plug.
#
# Also, you may not want to add any other Plug before the Approov Token plug to
# avoid your server from wasting resources in processing requests not having
# a valid Approov token.
#
# Following this advice's increases availability for your users during peak
# time or in the event of a DoS attack, because your server is refusing the
# connection without further processing other paths in your code. We all know
# that the BEAM design allows to cope and be more resilient to this scenarios,
# but doesn't hurt to play on the safe side.

pipeline :approov_token do
  plug YourAppWeb.ApproovTokenPlug
end

scope "/" do

  # The API pipeline is an exception to the above advice because it's setting
  # the response content type to JSON.
  pipe_through :api
  pipe_through :approov_token

  # Your endpoints go after this line, for example:
  get "/", YourAppWeb, YourAppWeb.ApiController, :index
  post "/auth/register", YourAppWeb.AuthController, :register
  post "/auth/login", YourAppWeb.AuthController, :login
end
```


### Approov Token Check for Websockets Requests

For using Websockets in Elixir we have the excellent [Phoenix Channels](https://hexdocs.pm/phoenix/channels.html) abstraction provided by the Phoenix framework, that we can easily secure with Approov.

First, open the file where you establish the websocket connection, maybe `lib/your_app_web/user_socket.ex` or whatever file name you use, and add to it this code:

```elixir
defp _authorize(socket, params, connect_info) do

  headers = Map.merge(params, connect_info)

  # Always perform the Approov token check before the User Authentication.
  with {:ok, _approov_token_claims} <- ApproovToken.verify_token(headers),
       {:ok, current_user} <- Echo.User.authorize(params: params) do

    socket = Phoenix.Socket.assign(socket, context: %{current_user: current_user})

    {:ok, socket}
  else
    {:error, _reason} ->
      :error
  end
end
```

The above `_authorize/2` function needs to be the first one to be invoked in your `connect/3` function pipeline. For example:

```elixir
def connect(params, socket, _connect_info) do
  socket
  |> _authorize(params)
  |> _other_stuff()
end
```

This will ensure that the websocket connection is only established when a valid Approov token is provided, otherwise it's rejected.

Next, you need to secure each event coming through the websocket via a Phoenix Channel, and for that you just need to add to your Phoenix Channel module the following code:

```elixir
defp _authorized(action, payload, socket) do
  # Always perform the Approov token check before the User Authorization.
  with {:ok, _approov_token_claims} <- ApproovToken.verify_token(payload),
       {:ok, current_user} <- YourApp.User.authorize(params: payload),
       true <- YourApp.User.can_do_action?(action, current_user) do
    {:ok, socket}
  else
    {:error, _reason} ->
      # You may want to add some logging here
      :error

    false ->
      # You may want to add some logging here
      :error
  end
end
```

Now, in the `join/3` function and in each `handle_in/3` function of your Phoenix Channel module you need to wrap all your logic in a call to `_authorized/3`:

```elixir
def join("channel:event", payload, socket) do
  case _authorized(:join, payload, socket) do
    {:ok, socket} ->

      # YOUR LOGIC GOES HERE...

      {:ok, socket}

    _ ->
      {:error, %{reason: "Whoops, something went wrong!"}}
  end
end

def handle_in("event:action", payload, socket) do
  case _authorized(:action_name, payload, socket) do
    {:ok, socket} ->

      # YOUR LOGIC GOES HERE...

      {:noreply, socket}

    _ ->
      {:noreply, socket}
  end
end
```

A full working example for a simple Elixir Phoenix Channels server can be found at [src/approov-protected-server/token-check/echo](/src/approov-protected-server/token-check/echo).

[TOC](#toc---table-of-contents)


## Test your Approov Integration

In this section you will see how you can use the Approov CLI to generate sample Approov tokens to test your Approov Integration in the backend without relying in the Mobile App(s) that the backend will be serving.

### Test your Approov Integration with HTTP Requests

The following examples below uses cURL to test the user authentication endpoints, where you need to adjust `auth/register` and `auth/login` to the ones you use. The process of adding the Approov token remains the same for any type of http request, therefore if you don't have user authentication endpoints you can still use the below examples as a reference to test your endpoints.

#### User Registration and Login

Generate a valid token example from the Approov Cloud service:

```bash
approov token -genExample your.api.domain.com
```

Let's try to register the user with the Approov protected endpoint:

```bash
curl -i --request POST 'https://your.api.domain.com/auth/register' \
  --header 'X-Approov-Token: APPROOV_VALID_TOKEN_EXAMPLE_HERE' \
  --data username=test@mail.com \
  --data password=your-pass-here
```

The request should be accepted. For example:

```bash
HTTP/2 200
...

{"id":"B4C20F1BBC39F610CF4608F83A06DEA85884D77C854BBB3D10EF239641B9B861"}
```

Next, let's login the user with the Approov protected endpoint:

```bash
curl -i --request POST 'your.api.domain.com/auth/login' \
  --header 'X-Approov-Token: APPROOV_VALID_TOKEN_EXAMPLE_HERE' \
  --data username=test@mail.com \
  --data password=your-pass-here
```

The request should be accepted. For example:

```text
HTTP/2 200
...

{"token":"Bearer AUTHORIZATION_VALID_TOKEN"}
```

Finally we have the Bearer Authorization token that is required to represent a logged-in user when doing queries to the backend. To note that the backend should only check the Authorization token after it is able to successfully check the Approov token.


#### With Valid Approov Tokens

Generate a valid token example from the Approov Cloud service:

```bash
approov token -genExample your.api.domain.com
```

Then make the request with the generated token:

```bash
curl -i --request GET 'your.api.domain.com/users' \
  --header 'X-Approov-Token: APPROOV_VALID_TOKEN_EXAMPLE_HERE' \
  --header 'Authorization: Bearer AUTHORIZATION_VALID_TOKEN' \
  --header "Content-Type: application/json"
```

The request should be accepted. For example:

```text
HTTP/2 200
...

{
  [
    "id":"B4C20F1BBC39F610CF4608F83A06DEA85884D77C854BBB3D10EF239641B9B861"
  ]
}
```

#### With Invalid Approov Tokens

Generate an invalid token example from the Approov Cloud service:

```bash
approov token -type invalid -genExample your.api.domain.com
```

Then make the request with the generated token:

```bash
curl -i --request GET 'your.api.domain.com/users' \
  --header 'X-Approov-Token: APPROOV_INVALID_TOKEN_EXAMPLE_HERE' \
  --header 'Authorization: Bearer AUTHORIZATION_VALID_TOKEN' \
  --header "Content-Type: application/json"
```

The above request should fail with an Unauthorized error. For example:

```text
HTTP/2 401

...

{}
```

Despite the Authorization token being a valid one, the server refuses to accept the request, because its presented with an invalid Approov token. We always recommend for the Approov token to be checked before the Authorization token.

[TOC](#toc---table-of-contents)


### Test your Approov Integration with Websockets

Phoenix Channels cannot be tested using cURL, because you need to establish a websocket connection and keep it open, therefore you will need to use Postman or another software that supports websockets.

We recommend the use of Postman and we provide [this collection](https://raw.githubusercontent.com/approov/postman-collections/master/quickstarts/echo/echo-websockets.postman_collection.json) to help you get started.

You can check [this examples](./../src/approov-protected-server/token-check/echo/README.md#testing-with-postman) to see a practical example of this collection being used. Remember that when following this Postman examples you need to generate the Approov tokens with the Approov CLI, or use the same Approov secret from the examples.

To generate a valid Approov token from the Approov Cloud service:

```bash
approov token -genExample your.api.domain.com
```

To generate an invalid Approov token example from the Approov Cloud service:

```bash
approov token -type invalid -genExample your.api.domain.com
```

[TOC](#toc---table-of-contents)
